type UnLockSuccess = 
 record {
   activeUntil: int;
   createdAt: int;
   id: text;
   lockedTickets: vec LockedTicket;
   owner: principal;
   price: nat;
   status: LotteryStatus;
   supply: nat;
   tickets: vec Ticket;
   token: Token;
 };
type UnLockResult = 
 variant {
   err: UnLockError;
   ok: UnLockSuccess;
 };
type UnLockError = 
 variant {
   Expired;
   LotteryNotFound;
   NotLocked;
   Unpaied;
 };
type TransferSuccess = record {blockHeight: nat64;};
type TransferResult = 
 variant {
   err: TransferError;
   ok: TransferSuccess;
 };
type TransferError__1 = 
 variant {
   BadFee: record {expected_fee: Tokens;};
   InsufficientFunds: record {balance: Tokens;};
   TxCreatedInFuture;
   TxDuplicate: record {duplicate_of: BlockIndex;};
   TxTooOld: record {allowed_window_nanos: nat64;};
 };
type TransferError = 
 record {
   kind: TransferError__1;
   message: opt text;
 };
type Tokens = record {e8s: nat64;};
type Token = 
 record {
   canisterId: text;
   index: nat;
   standard: text;
 };
type Ticket = 
 record {
   count: nat;
   participant: principal;
   payeeSubAccount: SubAccount;
   ticketId: text;
 };
type SubAccount = blob;
type PrepareSuccess = text;
type PrepareResult = 
 variant {
   err: PrepareError;
   ok: PrepareSuccess;
 };
type PrepareError = 
 variant {
   AlreadyExists;
   InvalidActiveUntil;
   InvalidPrice;
   InvalidSupply;
   NotAllowed;
   NotOwned;
 };
type Lottery__1 = 
 record {
   activeUntil: int;
   createdAt: int;
   id: text;
   lockedTickets: vec LockedTicket;
   owner: principal;
   price: nat;
   status: LotteryStatus;
   supply: nat;
   tickets: vec Ticket;
   token: Token;
 };
type LotteryStatus = 
 variant {
   Active;
   InsufficientParticipants;
   Selected: record {winner: principal;};
 };
type Lottery = 
 service {
   acceptCycles: () -> ();
   availableCycles: () -> (nat) query;
   cancelPreparation: () -> (bool);
   create: () -> (CreateResult);
   getCreators: () -> (vec principal);
   getLotteries: (nat, nat) -> (vec Lottery__1);
   getLottery: (text) -> (opt Lottery__1);
   getPreparation: () -> (opt Lottery__1);
   getTimestamp: () -> (int);
   getTotalCount: () -> (nat);
   lock: (text, nat) -> (LockResult);
   prepare: (nat, nat, nat, text, nat, text) -> (PrepareResult);
   refundICP: (text, text) -> (opt TransferResult);
   setMinimalDuration: (nat) -> ();
   setOwner: (principal) -> ();
   setSettlementBuffer: (nat) -> ();
   unlock: (text, text) -> (UnLockResult);
 };
type LockedTicket = 
 record {
   expiredAt: int;
   ticket: Ticket;
 };
type LockSuccess = 
 record {
   expiredAt: int;
   ticket: Ticket;
 };
type LockResult = 
 variant {
   err: LockError;
   ok: LockSuccess;
 };
type LockError = 
 variant {
   CalledByOwner;
   Ended;
   Full;
   LotteryNotFound;
 };
type CreateSuccess = text;
type CreateResult = 
 variant {
   err: CreateError;
   ok: CreateSuccess;
 };
type CreateError = 
 variant {
   NotExists;
   NotTransferred;
 };
type BlockIndex = nat64;
service : () -> Lottery
